<!doctype html>
<html>
<head><title>PromiseMeSpeed Compliance Tests</title></head>
<body>
<center><h1>Compliance Tests for PromiseMeSpeed</h1></center>
<pre id="scriptError" style="color:#c00"></pre>
<table style="border-collapse:collapse;max-width:100%"><thead>
	<tr><th>Vendor</th><th>Code Snippet</th><th>Expected Output</th><th>Actual Output</th></tr>
</thead><tbody id="testResults"></tbody></table>
<script src="PromiseMeSpeed.src.js" defer=""
		onerror="document.getElementById('scriptError').textContent+=arguments[0].message+'\n\n'"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/bluebird/3.5.4/bluebird.core.min.js" defer=""
		onerror="document.getElementById('scriptError').textContent+=arguments[0].message+'\n\n'"></script>
<script>
"use strict";
// my own test manager with lots of Promise tests
addEventListener("DOMContentLoaded", (function(nativeBrowserPromise, allPromiseTests){
	var promisesAndVendors = [[window.SPromise, "SPromise"], [nativeBrowserPromise, "native"], [window.Promise, "Bluebird"]];
	var testResultsTbody = document.getElementById("testResults");
	var lastFailedTestRow = null;
	var JSON_stringify = JSON.stringify;
	for (var promiseVendorIndex = 0; promiseVendorIndex < promisesAndVendors.length; promiseVendorIndex++) {
		doTestsForVendor( promisesAndVendors[promiseVendorIndex] );
	}
	function prettyStringify(array){ /// JSON.stringify mixed with pretty-printing
		var result = '';
		for (var i=0; i<array.length; i++) {
			var val = array[i];
			result += (typeof val=== "object" ? JSON_stringify(val, null, '\t') : val) + "\n";
		}
		return result.slice(0, -1);
	}
	function doTestsForVendor(promiseVendor){
		var expectations = [];
		var results = [];
		
		function bindArrayPrototypePush(expectationsOrResults){
			return function(){
				for (var i=0; i<arguments.length; i++)
					expectationsOrResults.push(arguments[i]);
			};
		}
		
		for (var testIndex = 0; testIndex < allPromiseTests.length; testIndex++) {
			// bind array.prototype.push to the two arrays, then the test will act on the arrays
			try {
				allPromiseTests[testIndex](
					promiseVendor[0],
					bindArrayPrototypePush(expectations[testIndex] = []),
					bindArrayPrototypePush(results[testIndex] = [])
				);
			} catch(e) {
				e && results[testIndex].push(e.message + e.stack);
			}
			
		}
		setTimeout(function(){
			// now, check to see which arrays are the same and which differ to determine which test failed
			for (var testIndex = 0; testIndex < allPromiseTests.length; testIndex++) {
				var row = testResultsTbody.insertRow(-1);
				var testExpected = expectations[testIndex];
				var testResults = results[testIndex];
				row.insertCell(-1).textContent = promiseVendor[1]; // promise vendor name
				var codePreTag = row.insertCell(-1).appendChild(document.createElement("pre"));
				codePreTag.className = 'test-code-snippet';
				codePreTag.textContent = allPromiseTests[testIndex].toString(); // test code
				row.insertCell(-1).appendChild(document.createElement("pre")).textContent = (
					prettyStringify(testExpected, null, "\t")
				); // expected results
				var actualResultsCell = row.insertCell(-1);
				actualResultsCell.appendChild(document.createElement("pre")).textContent = (
					prettyStringify(testResults, null, "\t")
				); // actual results
				var areTheSameSuccess = true;
				if (testExpected.length !== testResults.length) areTheSameSuccess = false;
				if (areTheSameSuccess) {
					// check for any results that fail to match what was expected
					for (var resultIndex=0; resultIndex < testExpected.length; resultIndex++)
						if (testExpected[resultIndex] !== testResults[resultIndex])
							areTheSameSuccess = false;
				}
				// green => success; red => failure
				actualResultsCell.style.background = areTheSameSuccess ? "#dfd" : "#fdd";
				if (!areTheSameSuccess) {
					// move it up higher to the end of the fail section
				    testResultsTbody.insertBefore(
						row,
						lastFailedTestRow ? lastFailedTestRow.nextSibling : testResultsTbody.firstChild
					);
					lastFailedTestRow = row;
				}
			}
		}, 250); // arbitrary time of 250ms, after which we assume that all the promises are done
	}
}).bind(0,
window.Promise, // Bluebird overides window.Promise, so we must get window.Promise before Bluebird loads up
[function(PromiseConstructor, expect, output){
	// basic expectation for the three common methods
	expect(
		'"then" in promise', '"catch" in promise', '"finally" in promise',
		'Promise.all', 'Promise.race', 'Promise.reject', 'Promise.resolve'
	);
	
	var instance = new PromiseConstructor(function(){});
	
	if (typeof instance.then === "function") output('"then" in promise');
	if (typeof instance.catch === "function") output('"catch" in promise');
	if (typeof instance.finally === "function") output('"finally" in promise');
	
	if (typeof PromiseConstructor.all === "function") output('Promise.all');
	if (typeof PromiseConstructor.race === "function") output('Promise.race');
	if (typeof PromiseConstructor.reject === "function") output('Promise.reject');
	if (typeof PromiseConstructor.resolve === "function") output('Promise.resolve');
}, function(PromiseConstructor, expect, output){
	// Promise{accept}.then pipes the value
	expect('Promise{accept}.then pipe');
	new PromiseConstructor(function(accept){
		accept('Promise{accept}.then pipe');
	}).then(output);
}, function(PromiseConstructor, expect, output){
	// Promise.resolve.then pipes the value
	expect('Promise.resolve.then pipe');
	PromiseConstructor.resolve('Promise.resolve.then pipe').then(output);
}, function(PromiseConstructor, expect, output){
	// Promise{accept}.then.then pipes the value
	expect('[passing:] Promise{accept}.then.then pipe', 'Promise{accept}.then.then pipe');
	new PromiseConstructor(function(accept){
		accept('Promise{accept}.then.then pipe');
	}).then(function(value){
		output('[passing:] ' + value);
		return value;
	}).then(output);
}, function(PromiseConstructor, expect, output){
	// Promise{reject}.catch pipes the value
	expect('Promise{reject}.catch pipe');
	new PromiseConstructor(function(accept, reject){
		reject('Promise{reject}.catch pipe');
	}).catch(output);
}, function(PromiseConstructor, expect, output){
	// Promise{throw}.catch pipes the value
	expect('Promise{throw}.catch pipe');
	new PromiseConstructor(function(accept, reject){
		throw 'Promise{throw}.catch pipe';
	}).catch(output);
}, function(PromiseConstructor, expect, output){
	// Promise.reject.then pipes the value
	expect('Promise.reject.then pipe');
	PromiseConstructor.reject('Promise.reject.then pipe').then(function(){}, output);
}, function(PromiseConstructor, expect, output){
	// Promise.resolve.finally pipes no value
	expect(); // expect nothing
	PromiseConstructor.resolve().finally(output);
}, function(PromiseConstructor, expect, output){
	// Promise.reject.finally pipes no value
	expect(); // expect nothing
	PromiseConstructor.reject().finally(output);
}, function(PromiseConstructor, expect, output){
	// return value from .finally ignored for thenables
	expect('.finally transparency');
	PromiseConstructor.resolve('.finally transparency')
		.finally(function(){return '.finally is blocking'})
		.then(output);
}, function(PromiseConstructor, expect, output){
	// return value from .finally ignored for catchables
	expect('.finally transparency');
	PromiseConstructor.reject('.finally transparency')
		.finally(function(){return '.finally is blocking'})
		.catch(output);
}, function(PromiseConstructor, expect, output){
	// Promise{reject}.catch{throw}.then pipes the value
	expect(
		'[passing:] Promise{reject}.catch{throw}.catch pipe',
		'Promise{reject}.catch{throw}.catch pipe'
	);
	new PromiseConstructor(function(accept, reject){
		reject('Promise{reject}.catch{throw}.catch pipe');
	}).catch(function(value){
		output('[passing:] ' + value);
		throw value;
	}).catch(output);
}, function(PromiseConstructor, expect, output){
	// Promise{throw}.catch.then piping
	expect('thrown error msg', 'return from catch');
	new PromiseConstructor(function(accept, reject){throw 'thrown error msg'})
		.catch(function(value){output(value); return 'return from catch'})
		.then(output)
}, function(PromiseConstructor, expect, output){
	// '.catch' transparency for .catch.catch.then
	expect('Transparent resolved');
	new PromiseConstructor(function(accept, reject){accept('Transparent resolved');})
		.catch(function(){ output('1st ".catch" should transparently pass the resolved'); })
		.catch(function(){ output('2nd ".catch" should transparently pass the resolved'); })
		.then(output)
}, function(PromiseConstructor, expect, output){
	// '.resolve(Promise)' resolves to the resolution of the inner Promise
	expect('Promise.resolve(new Promise) resolves to the resolution of the inner promise');
	var promiseInput = new PromiseConstructor(function(accept, reject){
		accept("the resolution of the inner promise");
	});
	PromiseConstructor.resolve(promiseInput).then(function(value) {
		if (value === promiseInput)
			output('Promise.resolve(new Promise) is a promise');
		else
			output('Promise.resolve(new Promise) resolves to ' + value);
	});
}, function(PromiseConstructor, expect, output){
	// '.reject(Promise)' rejects the inner Promise itself
	expect('Promise.reject(new Promise) is a promise');
	var promiseInput = new PromiseConstructor(function(accept, reject){
		reject("the rejection of the inner promise");
	});
	PromiseConstructor.reject(promiseInput).catch(function(value) {
		if (value === promiseInput)
			output('Promise.reject(new Promise) is a promise');
		else
			output('Promise.reject(new Promise) rejects to ' + value);
	});
},  function(PromiseConstructor, expect, output){
	// '.resolve(Promise{reject()})' taints the resolution of the Promise
	expect('Promise.resolve(new Promise{reject()}) taints the resolution');
	PromiseConstructor.resolve(new PromiseConstructor(function(accept, reject){
		reject('Promise.resolve(new Promise{reject()}) taints the resolution');
	})).catch(output);
}, function(PromiseConstructor, expect, output){
	// .finally{throw}.catch check
	expect('.finally{throw}.catch');
	PromiseConstructor.resolve().finally(function(resolve){
		throw '.finally{throw}.catch';
	}).catch(output);
},  function(PromiseConstructor, expect, output){
	// `throw` after `resolve` does nothing
	expect('throw resolve() thenablity');
	new PromiseConstructor(function(accept){
		throw accept('throw resolve() thenablity');
	}).then(output);
}, function(PromiseConstructor, expect, output){
	// Promise without new throws error
	// SPromise should fail this test because it does not use `new`
	expect('Exception when constructed without `new`');
	try {
		PromiseConstructor(function(accept){accept()});
	} catch(e) {
 		output('Exception when constructed without `new`');
 	}
}, function(PromiseConstructor, expect, output){
	// stack overflow test to ensure that the promises can deal with deep nesting
	expect('No stack overflow inside of 4096 calls!');
	var i = 4096;
	new PromiseConstructor(function recurseDeeper(){
		try {
			if (i-- < 0) return output('No stack overflow inside of 4096 calls!');
			return new PromiseConstructor(recurseDeeper);
		} catch(e) {
			i = 0;
			output(e.message + e.stack);
		}
	});
}, function(PromiseConstructor, expect, output){
	// breadth test for many many functions called after a promise
	expect('16384 successful ".then"s');
	var promiseAcceptor;
	var instance = new PromiseConstructor(function(accept){promiseAcceptor = accept});
	function thenAfter(){}
	for (var i=0; i<16384; i++) {
		instance.then(thenAfter, thenAfter);
		instance.catch(thenAfter);
		instance.finally(thenAfter);
	}
	promiseAcceptor();
	for (var i=0; i<16384; i++) {
		instance.then(thenAfter, thenAfter);
		instance.catch(thenAfter);
		instance.finally(thenAfter);
	}
	output('16384 successful ".then"s');
}, function(PromiseConstructor, expect, output){
	// ensure that .toString returns [object Promise] for new instances
	expect('promise.toString() === "[object Promise]"');
	output('promise.toString() === ' + JSON.stringify(
		"" + new PromiseConstructor(function(){})
	));
}, function(PromiseConstructor, expect, output){
	// ensure that .toString returns [object Promise] for resolves
	expect('promise.toString() === "[object Promise]"');
	output('promise.toString() === ' + JSON.stringify(
		"" + PromiseConstructor.resolve(null)
	));
}, function(PromiseConstructor, expect, output){
	// ensure that .toString returns [object Promise] for rejections
	expect('promise.toString() === "[object Promise]"');
	output('promise.toString() === ' + JSON.stringify(
		"" + PromiseConstructor.reject(null)
	));
}, function(PromiseConstructor, expect, output){
	// nested thenability and order test
	expect('Checkpoint A: before inner .then');
	expect('Checkpoint B: inside inner .then');
	expect('Checkpoint C: after inner .then');
	expect('Checkpoint D: after outer .then');
	PromiseConstructor.resolve().then(function(){
		output('Checkpoint A: before inner .then');
		return new PromiseConstructor(function(accept, reject){
			output('Checkpoint B: inside inner .then');
			accept('Checkpoint D: after outer .then');
			output('Checkpoint C: after inner .then');
		});
	}).then(output);
}, function(PromiseConstructor, expect, output){
	// nested catchability and order test
	expect('Checkpoint A: before inner .catch');
	expect('Checkpoint B: inside inner .catch');
	expect('Checkpoint C: after inner .catch');
	expect('Checkpoint D: after outer .catch');
	PromiseConstructor.reject().catch(function(){
		output('Checkpoint A: before inner .catch');
		return new PromiseConstructor(function(accept, reject){
			output('Checkpoint B: inside inner .catch');
			reject('Checkpoint D: after outer .catch');
			output('Checkpoint C: after inner .catch');
		});
	}).catch(output);
}]), {once: 1});
</script>
<style>
	#testResults td, #testResults th {border: 1px solid;vertical-align:top}
	.test-code-snippet {
		min-height: 7em;
		margin: 0;
		overflow-y:scroll;
		font-variant-ligatures: none
	}
</style>
</body>
</html>
